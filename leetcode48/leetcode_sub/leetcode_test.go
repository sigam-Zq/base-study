package leetcode48

import (
	"strconv"
	"testing"
)

/*

3251. 单调数组对的数目 II



给你一个长度为 n 的 正 整数数组 nums 。

如果两个 非负 整数数组 (arr1, arr2) 满足以下条件，我们称它们是 单调 数组对：

两个数组的长度都是 n 。
arr1 是单调 非递减 的，换句话说 arr1[0] <= arr1[1] <= ... <= arr1[n - 1] 。
arr2 是单调 非递增 的，换句话说 arr2[0] >= arr2[1] >= ... >= arr2[n - 1] 。
对于所有的 0 <= i <= n - 1 都有 arr1[i] + arr2[i] == nums[i] 。
请你返回所有 单调 数组对的数目。

由于答案可能很大，请你将它对 109 + 7 取余 后返回。



示例 1：

输入：nums = [2,3,2]

输出：4

解释：

单调数组对包括：

([0, 1, 1], [2, 2, 1])
([0, 1, 2], [2, 2, 0])
([0, 2, 2], [2, 1, 0])
([1, 2, 2], [1, 1, 0])
示例 2：

输入：nums = [5,5,5,5]

输出：126



提示：

1 <= n == nums.length <= 2000
1 <= nums[i] <= 1000



*/

func TestXxx(t *testing.T) {
	for i, v := range []struct {
		f    func([]int) int
		nums []int
		want int
	}{
		{
			f:    countOfPairs,
			nums: []int{2, 3, 2},
			want: 4,
		},
		{
			f:    countOfPairs,
			nums: []int{5, 5, 5, 5},
			want: 126,
		},
		{
			f:    countOfPairs,
			nums: []int{21, 26, 30, 30, 30, 31, 33, 33, 37, 41, 42, 43, 44, 47, 50, 50, 50, 52, 54, 54, 61, 64, 64, 65, 65, 67, 69, 70, 77, 77, 78, 78, 78, 79, 79, 83, 88, 90, 92, 93, 94, 94, 94, 94, 96, 98, 98, 105, 108, 110, 111, 111, 112, 112, 115, 117, 119, 121, 121, 122, 124, 125, 125, 127, 129, 130, 132, 134, 139, 149, 149, 151, 154, 154, 155, 160, 161, 166, 167, 169, 170, 170, 170, 171, 173, 174, 177, 177, 178, 178, 184, 185, 186, 187, 188, 189, 190, 192, 193, 197, 197, 199, 199, 203, 203, 204, 207, 208, 209, 218, 220, 224, 225, 225, 231, 231, 232, 234, 239, 244, 248, 249, 250, 252, 257, 257, 258, 258, 259, 260, 260, 260, 262, 263, 263, 267, 267, 268, 272, 275, 276, 281, 283, 285, 285, 286, 287, 288, 294, 300, 300, 301, 304, 309, 311, 315, 316, 317, 319, 320, 321, 321, 324, 331, 332, 332, 334, 335, 340, 340, 344, 345, 349, 349, 351, 358, 358, 358, 360, 362, 364, 364, 365, 365, 367, 368, 369, 372, 373, 374, 376, 376, 379, 382, 384, 384, 384, 385, 385, 390, 391, 391, 395, 399, 399, 401, 402, 404, 407, 411, 413, 413, 414, 419, 422, 423, 423, 424, 425, 427, 429, 432, 436, 437, 442, 444, 444, 445, 448, 449, 451, 453, 455, 464, 464, 465, 471, 481, 481, 483, 484, 485, 485, 488, 490, 492, 494, 494, 495, 496, 501, 503, 505, 511, 512, 517, 518, 518, 529, 532, 533, 538, 539, 539, 541, 542, 552, 552, 553, 554, 557, 558, 560, 563, 568, 568, 568, 573, 575, 576, 576, 576, 577, 578, 584, 585, 587, 589, 589, 589, 590, 593, 598, 599, 605, 610, 611, 611, 612, 614, 616, 617, 617, 618, 618, 623, 625, 626, 630, 633, 635, 635, 637, 638, 639, 640, 641, 646, 649, 650, 651, 652, 653, 665, 668, 670, 670, 670, 673, 673, 674, 677, 677, 681, 681, 686, 687, 688, 689, 690, 692, 692, 693, 697, 698, 700, 700, 701, 704, 704, 706, 706, 707, 708, 708, 709, 710, 712, 713, 715, 717, 719, 723, 726, 726, 726, 732, 738, 739, 740, 740, 741, 741, 741, 742, 743, 743, 747, 749, 752, 757, 760, 761, 762, 767, 775, 777, 779, 783, 786, 787, 787, 790, 790, 790, 792, 793, 797, 797, 798, 800, 802, 805, 806, 809, 810, 812, 816, 822, 823, 825, 827, 830, 833, 834, 836, 839, 841, 850, 856, 857, 858, 859, 861, 863, 863, 866, 869, 870, 872, 874, 878, 879, 880, 883, 883, 885, 888, 889, 889, 890, 891, 892, 893, 893, 894, 894, 900, 900, 905, 907, 907, 915, 915, 915, 918, 921, 928, 932, 935, 937, 939, 940, 944, 946, 947, 948, 949, 952, 953, 953, 954, 954, 957, 960, 966, 967, 968, 969, 970, 971, 975, 975, 975, 978, 979, 979, 980, 981, 981, 982, 985, 987, 988, 989, 990, 992, 993, 997, 998},
			want: 470840565,
		},
	} {
		t.Run(strconv.Itoa(i)+"-test", func(t *testing.T) {
			if got := v.f(v.nums); got != v.want {
				t.Errorf(" err got %v  want %v  \n", got, v.want)
			}
		})

	}
}

func countOfPairs(nums []int) int {
	n := len(nums)
	maxNum := 0
	for _, v := range nums {
		if v > maxNum {
			maxNum = v
		}
	}

	// dp[i][j] 表示 当 arr1[i] = j 的时候有 dp[i][j] 种可能的组合
	dp := make([][]int, n)
	for i := range dp {
		dp[i] = make([]int, maxNum+1)
	}
	// dp[0][maxNum-1] = 1
	for v := 0; v <= nums[0]; v++ {
		dp[0][v] = 1
	}

	// log.Printf("before dp %v \n", dp)
	mod := int(1e9 + 7)
	for i := 1; i < n; i++ {
		// for v2 := 0; v2 <= nums[i]; v2++ {
		// 	for v1 := 0; v1 <= v2; v1++ {
		// 		if nums[i-1]-v1 >= nums[i]-v2 {
		// 			dp[i][v2] = (dp[i][v2] + dp[i-1][v1]) % mod
		// 		}
		// 	}
		// }
		d := max(0, nums[i]-nums[i-1])
		for j := d; j <= nums[i]; j++ {
			if j == 0 {
				dp[i][j] = dp[i-1][j-d]
			} else {
				dp[i][j] = (dp[i][j-1] + dp[i-1][j-d]) % mod
			}
		}

		// log.Printf("i %d before dp %v \n", i, dp)
	}

	// log.Printf("after dp %v \n", dp)
	res := 0

	for _, v := range dp[n-1] {
		res = (res + v) % mod
	}

	return res
}

/*
方法一：动态规划
思路与算法

我们使用动态规划来解决本题目，定义 dp[i][j] 表示当 arr
1
​
 [i]=j 时，前 i+1 个元素组成的单调数组的数目。

因为 arr
1
​
 [0] 可以为 0 到 nums[0] 之间的任意数，初始化 dp[0][j]=1，其中 j 小于 nums[0]，其它初始化为零。

我们遍历数据，并且枚举 arr
1
​
  中之前和现在的值，按照题目要求的检查单调性，可得到转移方程 dp[i][v
2
​
 ]=∑dp[i−1][v
1
​
 ]。

其中满足 v
1
​
 ≤v
2
​
  和 nums[i−1]−v
1
​
 ≥nums[i]−v
2
​
 ≥0。

上述方法的代码，可参考题目「单调数组对的数目 I」的题解。

在上面动态规划的转移方程中，我们观察 dp[i][j] 的公式，可以发现它是 dp[i−1] 的子数组的和。其中 dp[i][j] 和 dp[i][j−1]，类似于前缀和数组中相邻的两项，并且由 nums[i−1]−v
1
​
 ≥nums[i]−v
2
​
 ≥0 的限制条件，我们可以推导出 v
2
​
 ≥nums[i]−nums[i−1]+v
1
​
 。

再结合 v
2
​
 ≥v
1
​
 ，我们可以得到 v
2
​
 ≥v
1
​
 +d，其中 d=max(0,nums[i]−nums[i−1])。

通过上面的观察和推导，我们可以得到 dp[i][j] 和 dp[i][j−1] 的关系：dp[i][j]=dp[i][j−1]+dp[i−1][j−d]。

由此我们得到新的动态转移方程，优化之前算法的复杂度。最后，我们返回 dp[n−1] 的和即为结果。


*/

func countOfPairsLeetCode(nums []int) int {
	n := len(nums)
	m := 0
	for _, num := range nums {
		if num > m {
			m = num
		}
	}
	mod := int(1e9 + 7)
	dp := make([][]int, n)
	for i := range dp {
		dp[i] = make([]int, m+1)
	}
	for a := 0; a <= nums[0]; a++ {
		dp[0][a] = 1
	}
	for i := 1; i < n; i++ {
		d := max(0, nums[i]-nums[i-1])
		for j := d; j <= nums[i]; j++ {
			if j == 0 {
				dp[i][j] = dp[i-1][j-d]
			} else {
				dp[i][j] = (dp[i][j-1] + dp[i-1][j-d]) % mod
			}
		}
	}
	res := 0
	for _, num := range dp[n-1] {
		res = (res + num) % mod
	}
	return res
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

/*

问

题解得到 状态转移方程

dp[i][j]=dp[i][j−1]+dp[i−1][j−d]

请给出 推理出该状态转移方程的过程
要求详细具体

可根据 num = [5,5,5,5]
的例子一步步详细解释如何得出上述状态转移方程的


答


要推导出状态转移方程 \( dp[i][j] = dp[i][j-1] + dp[i-1][j-d] \)，我们需要理解如何构建单调数组对 \((arr1, arr2)\) 满足给定条件。我们将通过一个例子来详细解释这个过程。

### 问题分析

给定一个数组 `nums`，我们需要找到所有可能的单调数组对 \((arr1, arr2)\)，使得：

1. \( arr1[i] + arr2[i] = nums[i] \) 对于所有 \( i \)。
2. \( arr1 \) 是单调非递减的。
3. \( arr2 \) 是单调非递增的。

### 动态规划思路

我们使用动态规划来解决这个问题。定义 \( dp[i][j] \) 表示前 \( i \) 个元素中，构造出单调数组对的方案数，其中 \( arr1[i] = j \)。

#### 初始化

- \( dp[0][j] = 1 \) 对于所有 \( 0 \leq j \leq nums[0] \)，因为只有一种方式构造第一个元素的数组对，即 \( arr1[0] = j \) 且 \( arr2[0] = nums[0] - j \)。

#### 状态转移

对于每个 \( i \) 和 \( j \)，我们需要考虑如何从前一个状态转移到当前状态：

1. **保持 \( arr1 \) 的单调性**：如果 \( arr1[i] = j \)，那么 \( arr1[i-1] \) 必须小于等于 \( j \)。因此，我们可以从 \( dp[i-1][0] \) 到 \( dp[i-1][j] \) 中的任意一个状态转移过来。

2. **保持 \( arr2 \) 的单调性**：如果 \( arr1[i] = j \)，那么 \( arr2[i] = nums[i] - j \)，而 \( arr2[i-1] \) 必须大于等于 \( arr2[i] \)。因此，\( arr1[i-1] \) 必须小于等于 \( nums[i-1] - (nums[i] - j) = j - d \)，其中 \( d = nums[i] - nums[i-1] \)。

结合这两个条件，我们得到：

\[ dp[i][j] = \sum_{k=0}^{j} dp[i-1][k] \]

为了优化计算，我们可以使用前缀和来快速计算这个和：

\[ dp[i][j] = dp[i][j-1] + dp[i-1][j-d] \]

### 例子分析

考虑 `nums = [5, 5, 5, 5]`：

- **初始化**：对于 \( i = 0 \)，我们有 \( dp[0][j] = 1 \) 对于 \( 0 \leq j \leq 5 \)。

- **状态转移**：
  - 对于 \( i = 1 \)，我们计算 \( dp[1][j] \)：
    - \( dp[1][0] = dp[0][0] = 1 \)
    - \( dp[1][1] = dp[1][0] + dp[0][1] = 2 \)
    - 继续类似的计算，直到 \( j = 5 \)。

通过这种方式，我们可以逐步计算出所有可能的单调数组对的数量。

### 总结

通过动态规划和前缀和的结合，我们可以有效地计算出满足条件的单调数组对的数量。状态转移方程 \( dp[i][j] = dp[i][j-1] + dp[i-1][j-d] \) 通过考虑单调性条件和前缀和优化得出。


*/
