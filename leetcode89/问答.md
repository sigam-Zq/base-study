### 综合回答

我们正在讨论的代码实现是通过动态规划和位运算来解决一个求最大子序列异或（XOR）值的问题。以下是对您的两个问题的详细解释：

---

### 1. **`findORs` 函数完成了什么工作？**

`findORs` 函数的目的是计算并返回一个数组中所有长度为 `k` 的子序列的所有可能的 **按位或（OR）** 结果。它通过动态规划（DP）来逐步更新子序列的 OR 结果。

#### **详细过程**：
- **初始化 `prev` 数组**：  
  `prev[j]` 用来记录在选择了 `j` 个元素时，所有可能的按位或结果。`prev[0][0] = true` 表示选择 0 个元素时，OR 结果为 0。
  
- **遍历 `nums`**：
  对于每一个元素 `nums[i]`，更新所有可能的 OR 结果。具体来说，`prev[j + 1][x | nums[i]]` 表示将 `nums[i]` 加入到已选的 `j` 个元素的 OR 结果中，得到新的 OR 结果。
  
  这样，每次遍历一个新元素时，`prev[j]` 会记录从前面 `j` 个元素的 OR 结果扩展到 `j+1` 个元素时的所有 OR 结果。

- **返回 `dp`**：
  最终，`findORs` 返回一个数组 `dp`，它包含了选择前 `i` 个元素时，所有可能的 `k` 个元素的 OR 结果。这个数组的作用是记录每个子序列的所有 OR 值，供后续的计算使用。

---

### 2. **为什么在下方的 `for` 循环时 `B` 使用 `len(nums) - i - 2`？**

在后续的计算中，两个数组 `A` 和 `B` 分别对应从数组的前半部分和后半部分选择子序列的 OR 结果。

- **`A[i]`** 存储的是从前 `i+1` 个元素的 OR 结果（即从左到右选择的结果）。
  
- **`B[len(nums) - i - 2]`** 存储的是从右到左的 OR 结果。为什么使用 `len(nums) - i - 2`？
  
  - `B` 是从反转后的数组中计算得到的，它记录的是从数组的后半部分选择子序列时的 OR 结果。
  - 对于原数组中索引为 `i` 的位置，反转后的数组对应的索引是 `len(nums) - i - 1`。
  - 因此，如果在循环中取 `len(nums) - i - 2`，是为了确保我们在处理子序列分割点时，正确地引用反转后的 `B` 数组中的 OR 结果。

#### **联系**：
- `A[i]` 和 `B[len(nums) - i - 2]` 这两个部分分别表示从前半部分和后半部分选择的 OR 结果。
- 结合这两个部分，我们可以在某个分割点计算 XOR 值，从而找到所有可能的子序列的最大 XOR 值。

这种方法通过从数组两端同时计算 OR 结果，并在中间进行分割，减少了计算复杂度，比直接枚举所有子序列要高效得多。

---

### **总结**
1. **`findORs` 函数的作用**是通过动态规划来计算并记录所有可能的按位 OR 结果，允许我们在后续的计算中迅速查找这些结果。
2. **`B` 使用 `len(nums) - i - 2` 的原因**是为了正确处理反转数组的索引，使得我们能将前半部分和后半部分的 OR 结果正确地结合并计算出最大 XOR 值。

这种方法结合了动态规划和位运算的优化，能有效减少暴力枚举的时间复杂度，从而在给定的约束条件下解决问题。